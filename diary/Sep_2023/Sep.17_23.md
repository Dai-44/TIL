### ログ
7:37  
- Rails応用のRSpec復習から始める。今日はやりたいこと沢山なので一つ一つ集中して頑張りたい。  

10:39  
- コーヒー飲みながら読書してリフレッシュしたので、卒業試験①の続きに取り組む。


### ゆる学び
- RSpec  
  - 画面上に同じ構成のブロックが複数あり、その先頭のものを指定したい場合は、`page.all('.box-footer')[0].click_button('更新する')`のように書く。`page.all('クラス名')`とインデックス番号で特定するイメージ。  
  - 埋め込みYouTubeが画面に表示されてるか確認する際は、`have_selector`でYouTube表示箇所のセレクタがあるか確認する方法が良さげ。  
  - YouTube, TwitterのIDは、Factory作成などせずにベタ打ちで入力しても良さそう。埋め込み作成欄に入力した後はプレビュー画面で表示されているか確認するのみで、その2つの整合性が取れてれば良さそうなので。  
  - 添付ファイルを選択するアクションをRSpecで記述する際は、`attach_file("name属性", "ファイル名")`とする。  
- 現場Rails Chapter5(RSpec)  
  - `Capybara`を利用するにあたり、`driven_by`でドライバの設定ができる。ドライバとは、ブラウザ相当の機能を利用するために必要なプログラムのこと。  
  - System Specでは、テスト終了時にDBが自動でロールバックされる。具体的には、`it`で記述された処理が実行されたあと、次の`it`の実行までにデータベースの状態は元に戻る。従い、あるテストケースが他のテストケースの影響を受けることは基本的にない。  
  - `FactoryBot`で作成したテストデータは、test環境用のDBに保存される。  
  - ファクトリ作成にあたり、ファクトリ名とクラスが異なる場合には`:class`オプションでクラスを指定できる。`factory :admin_user, class: User do`など。
- `git fetch`ではリモートの変更履歴を取得でき、`merge`せずにローカルで確認できる。具体的には、コマンド実行後に取得した変更履歴を反映する無名のブランチがローカルに作成される。このブランチは`FETCH_HEAD`という名前でチェクアウトできる。取得した変更をローカルのブランチに反映させる場合は、取り込むブランチに移動して`FETCH_HEAD`を`merge`する。  
- `let`で定義した文字列は、定義箇所となる`describe`または`context`の外でも呼び出すことができる。  
- `let`で定義した時点では、そのオブジェクトを実際に作成する処理はまだ実行されていない。初めて呼び出されたタイミングで初めて作成処理が実行されてDBに格納される。`let!`の場合は定義箇所で作成される。つまり、`let`の場合は「呼び出せばすぐにオブジェクトを作成できる」という準備がなされている状態と言える。(`let`と`let!`の違いについては、現場Railsのp.213参照。`let`で定義した定義名を直接呼び出す前にその定義の属性のみを呼び出すなどの記述をしてしまうと、保存されてないオブジェクトの属性を参照することになるのでエラーとなる。この場合は`let!`とすべき。)  
- 遅延評価は`let`で定義した場合の特徴であるため、`let`での共通化をせずに単にオブジェクトが必要な箇所で`FactoryBot.create`という形で定義した場合は、その場でDBにレコードが作成され格納される。  
- `it`での記述(期待する挙動や`it`の名前)が全く同じものについては、`shared_examples`として切り出して定義する。定義箇所は`it`が記述される各`describe`の外側（一階層上）。本来`it`が記述されていた箇所には、`it_behaves_like 'itの名前'`と記述する。  

