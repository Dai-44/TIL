### ログ
9:23  
- 現場Railsを今日の分の6ページ読み終わったので、中間試験②に入る。フォロー機能ってどう実装するんだろう。  

10:05  
- 中間試験の実装方針がある程度立ったので、これから手を動かしていく。こまめにコミットしつつ、とりあえずテストが通る状態に持っていく。

10:29  
- 卒業試験②の滑り出しは良い感じ。考えながら書いてる感は一応あって楽しい。フォロー機能はナニモワカラナイので後で調べる。

### ゆる学び
- 現場Rails Chapter 6  
  - RESTfulは、「どのようなインターフェイスが良いインターフェイスなのか」という指針のことであり、ルーティングの仕組みに大きな影響を与えている概念。Railsのルーティングは、RESTfulなインターフェイスを作りやすいように作られている。  
  - ルーティングは、リクエストをアクションへと道案内する「ルート」の集合  
  - ルーティングで定義される各ルートを構成する要素の一つである`HTTP`メソッドには、`GET`, `POST`, `PUT`, `PATCH`, `DELETE`の５種類があるが、一般的なブラウザから送ることができるのは`GET`リクエストと`POST`リクエストのみ。Railsでは、`_method`というリクエストパラメータの値に`PATCH`, `PUT`, `DELETE`という文字列が入った`POST`リクエストを、それぞれ`PATCH`, `PUT`, `DELETE`と解釈する。削除ボタン実装時に`view`ファイルに記述する`method: :delete`など。  
  - `tasks`といった「URLパターンの名前」は、対応するURLを簡単に生成するためのヘルパーメソッド（`tasks`の場合は`tasks_path`）を作り出す役割を果たしている。  
- Ruby超入門  
  - 配列から要素を削除する`pop`メソッドと`shift`メソッドは、削除した要素を返り値として返す。  
  ```
  drinks = ["Ruby", "PHP", "Java"]
  p drinks.pop # => "Java"
  p drinks.shift # => "Ruby"
  ```  
  - `split`メソッドに引数を渡さない場合は、スペースを区切りとして処理が実行される。  
  - ブロックを渡してメソッドを実行する際、ブロック変数に格納される各要素に対してあるメソッドを実行するだけの場合は、ブロックを省略した形で書くことができる。  
    `["abc", "123"].map { |text| text.reverse }`は`["abc", "123"].map(&:reverse)`と書き直せる。  
  - `break`と`next`は繰り返し処理を途中で終わらせるもの。`break`は以降のループも全て中止とするが、`next`はその回のみ中止して次のループに移る。また、`return`はメソッドの処理を途中で終えて抜ける仕組み。その時点で呼び出し元へ返るため、`return`以降の処理は実行されない。  
  - `puts`もメソッドであり、引数として受け取った値を出力する。`puts 1`では`1`が引数となっているため、省略せずに記述すると`puts (1)`となる。一般的なメソッドの実行時に引数を括弧内で渡すのと同じ構造。  
  - メソッド内で変数が定義されている(ローカル変数がある)場合、そのメソッドが呼び出されて実行処理が終わると、メソッド内のローカル変数とそこに格納されたオブジェクトは役目を終えて破棄される。  
  - `Array.new`を実行すると、`Array`クラスに属する空の配列オブジェクトが作成される。`Array.new(2, "Ruby")`のように引数を渡すと、`["Ruby", "Ruby"]`のように、第二引数のオブジェクトを第一引数の数だけ要素として持つ配列オブジェクトが作成される。  
  - 同じクラス内であれば、あるメソッドの処理の中で同じクラスに定義された他のメソッドを呼び出すことができる。他のメソッドの戻り値を処理に利用する際などに便利かも。呼び出される他のメソッドのレシーバは、特に指定がなければ呼び出しているメソッドのレシーバとなる。  
  - メソッドの処理の中で`p self`のように`self`を呼び出すと、そのメソッドのレシーバを得ることができる。  
  - ローカル変数のスコープはそれが定義されたメソッド内部のみ、インスタンス変数はそのインスタンス（オブジェクト）内部であれば複数のメソッドをまたいで使うことができる。インスタンス変数は代入が実行された時に生成される。寿命はそれが所属するオブジェクトと同じになるため、オブジェクトが存在する限りインスタンス変数も使うことができる。  
  - クラス内で定義された`initialize`メソッドは、そのクラスのインスタンスが作成されるタイミング(`new`メソッドが実行されたタイミング)で実行される。  
  - クラス名に対して`ancestors`メソッドを実行すると、そのクラスの親クラスと`include`されているモジュールが配列形式で表示される。  
  - 親クラスに定義されたメソッドと同名のメソッドが子クラスに定義された場合、処理内容が異なればオーバーライドがなされるため子クラスでの定義が優先される。親クラスの同名メソッドの処理を明示して定義したい場合は、子クラスのメソッド内に`super`と記述することで実現できる。  
  - `private`メソッドは、レシーバを指定して呼び出すことが禁じられたメソッド。言い換えると、それが定義されたクラス内のみでしか呼び出せない（クラス外部で呼び出すにはインスタンスなどレシーバを指定する必要があるため、呼び出しは不可能）。  
